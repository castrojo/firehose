---
// This component wraps release list and provides infinite scroll
// Data is passed via data attribute and hydrated client-side
---

<div class="infinite-scroll-container">
  <div id="release-list" class="releases">
    <!-- Initial releases rendered server-side in index.astro -->
    <slot />
  </div>
  
  <!-- Loading indicator -->
  <div id="loading-indicator" class="loading-indicator" style="display: none;">
    <div class="spinner"></div>
    <p>Loading more releases...</p>
  </div>
  
  <!-- Scroll trigger (invisible element) -->
  <div id="scroll-trigger" class="scroll-trigger"></div>
  
  <!-- End of content -->
  <div id="end-message" class="end-message" style="display: none;">
    <p>ðŸŽ‰ You've reached the end! All releases loaded.</p>
  </div>
</div>

<script>
  // Infinite scroll implementation using Intersection Observer
  (function() {
    const BATCH_SIZE = 30;
    let currentIndex = BATCH_SIZE; // Start after initial batch
    let isLoading = false;
    let allReleases: any[] = [];
    
    // Get data from parent element
    const container = document.querySelector('.infinite-scroll-container');
    const releaseList = document.getElementById('release-list');
    const scrollTrigger = document.getElementById('scroll-trigger');
    const loadingIndicator = document.getElementById('loading-indicator');
    const endMessage = document.getElementById('end-message');
    
    if (!container || !releaseList || !scrollTrigger) {
      console.error('Infinite scroll: Required elements not found');
      return;
    }
    
    // Get releases data from data attribute (passed from index.astro)
    const releasesData = container.getAttribute('data-releases');
    if (releasesData) {
      try {
        allReleases = JSON.parse(releasesData);
        console.log(`[InfiniteScroll] Loaded ${allReleases.length} releases for progressive loading`);
      } catch (e) {
        console.error('[InfiniteScroll] Failed to parse releases data:', e);
        return;
      }
    }
    
    // Function to render a single release card
    function renderReleaseCard(release: any): string {
      const data = release.data;
      const projectName = data.projectName || data.feedTitle || 'Unknown Project';
      const projectStatus = data.projectStatus || 'unknown';
      
      const formattedDate = data.isoDate
        ? new Date(data.isoDate).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
          })
        : null;
      
      // Get logo path
      const logoPath = getProjectLogoPath(projectName);
      
      // Truncate description to 2 sentences
      const description = data.projectDescription ? truncateToSentences(data.projectDescription, 2) : '';
      
      const projectStatusHtml = projectStatus !== 'unknown'
        ? `<span class="project-status ${projectStatus}">${projectStatus}</span>`
        : '';
      
      const projectDescriptionHtml = description
        ? `<p class="project-description" title="${escapeHtml(data.projectDescription || '')}">${escapeHtml(description)}</p>`
        : '';
      
      const dateHtml = formattedDate
        ? `<div class="release-date"><time datetime="${data.isoDate}">${formattedDate}</time></div>`
        : '';
      
      // Use contentSnippet for preview (markdown rendering happens server-side for initial batch)
      const contentPreview = data.contentSnippet
        ? `<div class="release-content">${escapeHtml(data.contentSnippet.substring(0, 300))}${data.contentSnippet.length > 300 ? '...' : ''}</div>`
        : '';
      
      return `
        <article 
          class="release-card" 
          data-pagefind-ignore
          data-project="${escapeHtml(projectName)}"
          data-status="${escapeHtml(projectStatus)}"
          data-date="${escapeHtml(data.isoDate ? data.isoDate.split('T')[0] : '')}"
        >
          <div class="release-header">
            <img 
              src="${logoPath}" 
              alt="${escapeHtml(projectName)} logo"
              class="project-logo"
              width="32"
              height="32"
              loading="lazy"
              onerror="this.style.display='none'"
            />
            <span class="project-name">${escapeHtml(projectName)}</span>
            ${projectStatusHtml}
          </div>
          ${projectDescriptionHtml}
          <h2 class="release-title">
            <a href="${escapeHtml(data.link)}" target="_blank" rel="noopener noreferrer">
              ${escapeHtml(projectName)} ${escapeHtml(data.title)}
            </a>
          </h2>
          ${dateHtml}
          ${contentPreview}
        </article>
      `;
    }
    
    // HTML escape utility
    function escapeHtml(text: string): string {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Get project logo path (client-side version of logoMapper.ts)
    function getProjectLogoPath(projectName: string): string {
      // Get base URL from page (injected via data attribute)
      const baseUrl = document.documentElement.getAttribute('data-base-url') || '/';
      
      if (!projectName) {
        return `${baseUrl}logos/placeholder.svg`;
      }
      
      // Normalize project name to match cncf/artwork structure
      const normalized = projectName
        .toLowerCase()
        .replace(/\s+/g, '-')      // Spaces to hyphens
        .replace(/[()]/g, '')      // Remove parentheses
        .replace(/\./g, '');       // Remove dots
      
      // Known edge cases (project name doesn't match artwork directory)
      const specialCases: Record<string, string> = {
        'in-toto': 'in-toto',
        'open-policy-agent': 'opa',
        'the-update-framework': 'tuf',
      };
      
      const logoDir = specialCases[normalized] || normalized;
      
      // Use icon format (square) for compact display in card headers
      return `${baseUrl}logos/${logoDir}/icon-color.svg`;
    }
    
    // Truncate description to 2 sentences (client-side version of truncate.ts)
    function truncateToSentences(text: string | undefined, sentenceCount: number = 2): string | undefined {
      if (!text || text.trim().length === 0) {
        return text;
      }
      
      // Split on sentence boundaries
      const sentenceRegex = /[.!?](?:\s+|$)/g;
      const matches = [];
      let match;
      
      while ((match = sentenceRegex.exec(text)) !== null) {
        matches.push(match.index + 1);
      }
      
      // If fewer sentences than requested, return original
      if (matches.length <= sentenceCount) {
        return text;
      }
      
      // Get position of nth sentence ending
      const truncateAt = matches[sentenceCount - 1];
      const truncated = text.slice(0, truncateAt).trim();
      
      return truncated + '...';
    }
    
    // Get active filters
    function getActiveFilters() {
      const projectFilterSelect = document.getElementById('filter-project') as HTMLSelectElement;
      const statusFilterSelect = document.getElementById('filter-status') as HTMLSelectElement;
      
      return {
        project: projectFilterSelect?.value || '',
        status: statusFilterSelect?.value || ''
      };
    }
    
    // Check if release matches active filters
    function releaseMatchesFilters(release: any, filters: { project: string, status: string }): boolean {
      const data = release.data;
      const projectName = data.projectName || data.feedTitle || 'Unknown';
      const status = data.projectStatus || 'unknown';
      
      const matchesProject = !filters.project || projectName === filters.project;
      const matchesStatus = !filters.status || status === filters.status;
      
      return matchesProject && matchesStatus;
    }
    
    // Load next batch of releases
    function loadMoreReleases() {
      if (isLoading || currentIndex >= allReleases.length) {
        return;
      }
      
      isLoading = true;
      if (loadingIndicator) loadingIndicator.style.display = 'block';
      
      const filters = getActiveFilters();
      
      // Simulate network delay for smooth UX (even though data is local)
      setTimeout(() => {
        const batch = allReleases.slice(currentIndex, currentIndex + BATCH_SIZE);
        
        batch.forEach(release => {
          // Only render if matches active filters
          if (releaseMatchesFilters(release, filters)) {
            const html = renderReleaseCard(release);
            if (releaseList) {
              releaseList.insertAdjacentHTML('beforeend', html);
            }
          }
        });
        
        currentIndex += BATCH_SIZE;
        isLoading = false;
        
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        
        // Check if we've loaded everything
        if (currentIndex >= allReleases.length) {
          if (scrollTrigger) scrollTrigger.style.display = 'none';
          if (endMessage) endMessage.style.display = 'block';
        }
        
        console.log(`[InfiniteScroll] Loaded batch, now showing ${Math.min(currentIndex + BATCH_SIZE, currentIndex + allReleases.length)}/${BATCH_SIZE + allReleases.length} releases`);
      }, 300);
    }
    
    // Apply filters to already-loaded infinite scroll cards
    function applyFiltersToInfiniteScrollCards() {
      const filters = getActiveFilters();
      
      // Only filter cards that were added by infinite scroll (not server-side or groups)
      const cards = releaseList?.querySelectorAll('.release-card[data-pagefind-ignore]');
      
      cards?.forEach(card => {
        const cardEl = card as HTMLElement;
        const project = cardEl.dataset.project || '';
        const status = cardEl.dataset.status || '';
        
        const matchesProject = !filters.project || project === filters.project;
        const matchesStatus = !filters.status || status === filters.status;
        
        cardEl.style.display = (matchesProject && matchesStatus) ? '' : 'none';
      });
    }
    
    // Set up Intersection Observer
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !isLoading) {
            loadMoreReleases();
          }
        });
      },
      {
        root: null,
        rootMargin: '200px', // Trigger 200px before reaching trigger element
        threshold: 0,
      }
    );
    
    observer.observe(scrollTrigger);
    
    // Listen for filter changes and apply to infinite scroll cards
    document.getElementById('filter-project')?.addEventListener('change', applyFiltersToInfiniteScrollCards);
    document.getElementById('filter-status')?.addEventListener('change', applyFiltersToInfiniteScrollCards);
    
    // Listen for clear filters button
    document.getElementById('clear-filters')?.addEventListener('click', () => {
      // Small delay to let FilterBar clear the selects first
      setTimeout(applyFiltersToInfiniteScrollCards, 50);
    });
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      observer.disconnect();
    });
  })();
</script>

<style>
  .infinite-scroll-container {
    position: relative;
  }
  
  .releases {
    /* Releases container */
  }
  
  .scroll-trigger {
    height: 1px;
    margin: 2rem 0;
  }
  
  .loading-indicator {
    text-align: center;
    padding: 2rem;
    color: var(--color-text-secondary, #57606a);
  }
  
  .spinner {
    width: 40px;
    height: 40px;
    margin: 0 auto 1rem;
    border: 4px solid rgba(0, 0, 0, 0.1);
    border-left-color: var(--color-accent-emphasis, #0969da);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .end-message {
    text-align: center;
    padding: 2rem;
    color: var(--color-text-secondary, #57606a);
    font-size: 0.875rem;
  }
</style>
