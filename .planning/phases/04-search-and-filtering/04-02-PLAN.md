---
phase: 04-search-and-filtering
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/components/FilterBar.astro
  - src/pages/index.astro
autonomous: true

must_haves:
  truths:
    - "User selects project filter and sees only releases from that project (instant)"
    - "User selects status filter and view updates instantly"
    - "User selects date range and view updates instantly"
    - "User clicks 'Clear filters' and returns to full unfiltered view"
    - "Filters apply client-side without page reload (<10ms)"
  artifacts:
    - path: "src/components/FilterBar.astro"
      provides: "Client-side filtering UI and logic"
      min_lines: 120
    - path: "src/pages/index.astro"
      provides: "FilterBar integration and data attributes on releases"
      contains: "FilterBar"
  key_links:
    - from: "src/components/FilterBar.astro"
      to: ".release-card elements"
      via: "querySelectorAll and dataset filtering"
      pattern: "querySelectorAll.*release-card"
    - from: "Filter dropdowns"
      to: "applyFilters function"
      via: "change event listeners"
      pattern: "addEventListener.*change"
    - from: "src/pages/index.astro"
      to: "FilterBar"
      via: "component import and unique lists"
      pattern: "<FilterBar"
---

<objective>
Implement client-side filtering that allows users to filter releases by project name, project status (graduated/incubating), and date range (7/30/90 days), with instant updates (<10ms) and no page reload.

Purpose: Enable users to narrow down 600+ releases to specific subsets of interest (e.g., "Show me all graduated projects from the last 30 days"). Filters complement search by providing structured faceted navigation.

Output: Working filter bar with dropdowns for project/status/date, client-side filtering logic, clear filters button, and visible result count.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/filtering-search.md
@src/pages/index.astro
@src/components/ReleaseCard.astro
@src/components/InfiniteScroll.astro
</context>

<tasks>

<task type="auto">
  <name>Extract unique filter values and add data attributes to releases</name>
  <files>src/pages/index.astro</files>
  <action>
Update index.astro to extract unique project names and statuses for filter dropdowns, and add data attributes to release cards for client-side filtering:

**1. Extract unique filter values (in frontmatter):**

After fetching and sorting releases, extract unique values:
```astro
// Extract unique project names (sorted alphabetically)
const uniqueProjects = [...new Set(sortedReleases.map(r => r.data.projectName || r.data.feedTitle))].filter(Boolean).sort();

// Extract unique statuses (graduated, incubating)
const uniqueStatuses = [...new Set(sortedReleases.map(r => r.data.projectStatus))].filter(Boolean).sort();
```

**2. Pass filter values to FilterBar component:**

The FilterBar component will need these lists for dropdown options. We'll pass them as props in the next task.

**3. Update ReleaseCard usage to include data attributes:**

Modify the `<ReleaseCard release={release} />` calls to pass through filtering metadata. Actually, ReleaseCard should add these attributes internally.

**4. Update ReleaseCard.astro to add data attributes:**

In ReleaseCard.astro, update the article element:
```astro
<article 
  class="release-card" 
  data-pagefind-body
  data-project={data.projectName || data.feedTitle || 'Unknown'}
  data-status={data.projectStatus || 'unknown'}
  data-date={data.isoDate ? data.isoDate.split('T')[0] : ''}
>
```

These data attributes enable efficient client-side filtering via dataset API.

**5. Update InfiniteScroll.astro's renderReleaseCard():**

Ensure dynamically rendered cards also have data attributes:
```typescript
return `
  <article 
    class="release-card" 
    data-pagefind-ignore
    data-project="${escapeHtml(data.projectName || data.feedTitle || 'Unknown')}"
    data-status="${escapeHtml(data.projectStatus || 'unknown')}"
    data-date="${escapeHtml(data.isoDate ? data.isoDate.split('T')[0] : '')}"
  >
```

**Why this approach:**
- Data attributes provide fast DOM-based filtering (no data structure needed)
- Unique lists populated server-side (no client-side extraction needed)
- All releases (SSR + infinite scroll) have consistent data attributes

**Avoid:**
- Client-side extraction of unique values (slower, wastes compute)
- Missing data attributes on infinite scroll items (would break filtering)
</action>
  <verify>
1. Build the project: `npm run build`
2. Inspect dist/index.html and confirm article elements have:
   - `data-project="..."`
   - `data-status="..."`
   - `data-date="YYYY-MM-DD"`
3. Log uniqueProjects in browser console (should be array of project names)
4. Log uniqueStatuses in browser console (should be ['graduated', 'incubating'])
5. Confirm no TypeScript errors
</verify>
  <done>
ReleaseCard components have data-project, data-status, and data-date attributes. Index.astro extracts unique project names and statuses for filter dropdowns. All releases (SSR and infinite scroll) have consistent data attributes for filtering.
</done>
</task>

<task type="auto">
  <name>Create FilterBar component with client-side filtering logic</name>
  <files>src/components/FilterBar.astro</files>
  <action>
Create FilterBar.astro component that provides filter UI (dropdowns, date range buttons) and implements client-side filtering logic:

**Component structure:**

1. **Props interface:**
```astro
---
interface Props {
  projects: string[];
  statuses: string[];
  totalCount: number;
}

const { projects, statuses, totalCount } = Astro.props;
---
```

2. **Filter UI elements:**
- Project dropdown (select with all project names)
- Status dropdown (graduated, incubating, all)
- Date range buttons (All, 7 days, 30 days, 90 days)
- Clear all filters button
- Result count display (e.g., "Showing 42 of 610 releases")

3. **HTML structure:**
```html
<div class="filter-bar">
  <div class="filter-controls">
    <select id="filter-project" aria-label="Filter by project">
      <option value="">All Projects</option>
      {projects.map(p => <option value={p}>{p}</option>)}
    </select>
    
    <select id="filter-status" aria-label="Filter by status">
      <option value="">All Statuses</option>
      {statuses.map(s => <option value={s}>{s}</option>)}
    </select>
    
    <div class="date-range-buttons" role="radiogroup" aria-label="Filter by date range">
      <button data-days="all" class="active">All</button>
      <button data-days="7">7 days</button>
      <button data-days="30">30 days</button>
      <button data-days="90">90 days</button>
    </div>
    
    <button id="clear-filters" aria-label="Clear all filters">Clear Filters</button>
  </div>
  
  <div class="filter-results">
    <span id="result-count" aria-live="polite" aria-atomic="true">
      Showing {totalCount} of {totalCount} releases
    </span>
  </div>
</div>
```

4. **Client-side filtering script:**

```typescript
<script>
  let activeDateRange = 'all';

  function applyFilters() {
    const projectFilter = (document.getElementById('filter-project') as HTMLSelectElement)?.value || '';
    const statusFilter = (document.getElementById('filter-status') as HTMLSelectElement)?.value || '';
    
    const releases = document.querySelectorAll('.release-card');
    let visibleCount = 0;
    
    // Calculate date threshold for date range filter
    const now = new Date();
    const dateThreshold = activeDateRange === 'all' ? null : 
      new Date(now.getTime() - parseInt(activeDateRange) * 24 * 60 * 60 * 1000);
    
    releases.forEach((release) => {
      const card = release as HTMLElement;
      const project = card.dataset.project || '';
      const status = card.dataset.status || '';
      const dateStr = card.dataset.date || '';
      const releaseDate = dateStr ? new Date(dateStr) : null;
      
      // Match logic
      const matchesProject = !projectFilter || project === projectFilter;
      const matchesStatus = !statusFilter || status === statusFilter;
      const matchesDate = !dateThreshold || (releaseDate && releaseDate >= dateThreshold);
      
      const visible = matchesProject && matchesStatus && matchesDate;
      
      card.style.display = visible ? '' : 'none';
      if (visible) visibleCount++;
    });
    
    // Update result count
    const totalCount = releases.length;
    const resultCount = document.getElementById('result-count');
    if (resultCount) {
      resultCount.textContent = `Showing ${visibleCount} of ${totalCount} releases`;
    }
  }

  function clearFilters() {
    // Reset dropdowns
    const projectSelect = document.getElementById('filter-project') as HTMLSelectElement;
    const statusSelect = document.getElementById('filter-status') as HTMLSelectElement;
    if (projectSelect) projectSelect.value = '';
    if (statusSelect) statusSelect.value = '';
    
    // Reset date range buttons
    document.querySelectorAll('.date-range-buttons button').forEach(btn => {
      btn.classList.remove('active');
    });
    const allButton = document.querySelector('[data-days="all"]');
    allButton?.classList.add('active');
    activeDateRange = 'all';
    
    applyFilters();
  }

  // Attach event listeners
  document.addEventListener('DOMContentLoaded', () => {
    document.getElementById('filter-project')?.addEventListener('change', applyFilters);
    document.getElementById('filter-status')?.addEventListener('change', applyFilters);
    document.getElementById('clear-filters')?.addEventListener('click', clearFilters);
    
    // Date range button listeners
    document.querySelectorAll('.date-range-buttons button').forEach(btn => {
      btn.addEventListener('click', (e) => {
        const target = e.currentTarget as HTMLElement;
        const days = target.dataset.days || 'all';
        
        // Update active state
        document.querySelectorAll('.date-range-buttons button').forEach(b => b.classList.remove('active'));
        target.classList.add('active');
        
        activeDateRange = days;
        applyFilters();
      });
    });
  });
</script>
```

5. **Styling (GitHub Primer inspired):**
- Horizontal layout with controls on left, result count on right
- Responsive: stack vertically on mobile
- Dropdowns styled like GitHub selects
- Date range buttons: pill-shaped, active state highlighted
- Clear button: secondary style, only enabled when filters active

**Performance:**
- Filtering <10ms for 610 items (pure DOM operations)
- No debouncing needed (instant feedback)

**Accessibility:**
- aria-label on all controls
- aria-live on result count
- Keyboard navigable (Tab, Space, Enter)

**Avoid:**
- Fetching data from API (use existing DOM)
- Complex state management (vanilla JS is sufficient)
- Filtering on every keystroke (dropdowns change on selection only)
</action>
  <verify>
1. Build and preview the site
2. Select a project from dropdown - only that project's releases visible
3. Select "graduated" status - only graduated projects visible
4. Click "30 days" button - only releases from last 30 days visible
5. Combine filters: Project + Status + Date - all filters apply simultaneously
6. Check result count updates correctly
7. Click "Clear Filters" - all releases visible again
8. Measure filter performance in DevTools (should be <10ms)
9. Test keyboard navigation (Tab through controls, Space/Enter to activate)
</verify>
  <done>
FilterBar component renders filter controls and implements client-side filtering logic. Filters apply instantly (<10ms) without page reload. Result count updates dynamically. Clear button resets all filters. Filters work in combination (project + status + date).
</done>
</task>

<task type="auto">
  <name>Integrate FilterBar into index.astro and style for responsive layout</name>
  <files>src/pages/index.astro</files>
  <action>
Integrate FilterBar component into index.astro and add responsive styling:

**1. Import FilterBar:**
```astro
import FilterBar from '../components/FilterBar.astro';
```

**2. Add FilterBar after SearchBar, before stats:**
```astro
<main class="container">
  <!-- Search bar -->
  <SearchBar />
  
  <!-- Filter bar -->
  <FilterBar 
    projects={uniqueProjects}
    statuses={uniqueStatuses}
    totalCount={sortedReleases.length}
  />
  
  <!-- Stats bar -->
  <div class="stats">
    ...
  </div>
</main>
```

**3. Add responsive CSS for filter bar layout:**

In index.astro's `<style>` section:
```css
/* Filter bar responsive layout */
.filter-bar {
  background: var(--color-bg-default);
  border: 1px solid var(--color-border-default);
  border-radius: 6px;
  padding: 1rem;
  margin-bottom: 1.5rem;
  display: flex;
  justify-content: space-between;
  align-items: center;
  gap: 1rem;
  flex-wrap: wrap;
}

.filter-controls {
  display: flex;
  gap: 0.75rem;
  align-items: center;
  flex-wrap: wrap;
  flex: 1;
}

.filter-controls select {
  padding: 0.5rem;
  border: 1px solid var(--color-border-default);
  border-radius: 6px;
  background: var(--color-bg-default);
  font-size: 0.875rem;
  color: var(--color-text-primary);
  min-width: 150px;
}

.date-range-buttons {
  display: flex;
  gap: 0.25rem;
  background: var(--color-bg-secondary);
  padding: 0.25rem;
  border-radius: 6px;
}

.date-range-buttons button {
  padding: 0.375rem 0.75rem;
  border: none;
  background: transparent;
  border-radius: 4px;
  font-size: 0.875rem;
  cursor: pointer;
  color: var(--color-text-secondary);
  transition: all 0.15s ease;
}

.date-range-buttons button.active {
  background: var(--color-bg-default);
  color: var(--color-text-primary);
  box-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
}

.date-range-buttons button:hover:not(.active) {
  color: var(--color-text-primary);
}

#clear-filters {
  padding: 0.5rem 1rem;
  background: var(--color-bg-secondary);
  border: 1px solid var(--color-border-default);
  border-radius: 6px;
  font-size: 0.875rem;
  cursor: pointer;
  color: var(--color-text-secondary);
  transition: all 0.15s ease;
}

#clear-filters:hover {
  background: var(--color-bg-default);
  color: var(--color-text-primary);
  border-color: var(--color-text-secondary);
}

.filter-results {
  color: var(--color-text-secondary);
  font-size: 0.875rem;
  white-space: nowrap;
}

/* Tablet (768px and below) */
@media (max-width: 768px) {
  .filter-bar {
    flex-direction: column;
    align-items: stretch;
  }
  
  .filter-controls {
    flex-direction: column;
    align-items: stretch;
  }
  
  .filter-controls select {
    width: 100%;
    min-width: unset;
  }
  
  .date-range-buttons {
    width: 100%;
    justify-content: space-between;
  }
  
  #clear-filters {
    width: 100%;
  }
  
  .filter-results {
    text-align: center;
  }
}

/* Mobile (480px and below) */
@media (max-width: 480px) {
  .filter-bar {
    padding: 0.75rem;
  }
  
  .date-range-buttons button {
    padding: 0.25rem 0.5rem;
    font-size: 0.75rem;
  }
}
```

**Why this layout:**
- Horizontal on desktop (efficient space usage)
- Stacked on mobile (touch-friendly, readable)
- Result count always visible
- Clear button accessible

**Avoid:**
- Fixed widths that break responsive layout
- Missing mobile breakpoints
</action>
  <verify>
1. Build and preview the site
2. Desktop (>768px): Verify filter bar is horizontal, controls on left, count on right
3. Tablet (768px): Verify filter bar stacks vertically
4. Mobile (480px): Verify all controls are full-width and touch-friendly
5. Apply filters and verify releases hide/show correctly
6. Verify result count updates in real-time
7. Verify no layout shift or overflow issues
8. Test on actual mobile device or DevTools device emulation
</verify>
  <done>
FilterBar is integrated into index.astro with responsive styling. Layout is horizontal on desktop, stacked on mobile. Filters work correctly with releases hiding/showing instantly. Result count displays and updates dynamically. UI is touch-friendly on mobile devices.
</done>
</task>

</tasks>

<verification>
**End-to-end filtering verification:**

1. Select "Kubernetes" from project filter - only Kubernetes releases visible
2. Select "graduated" from status filter - only graduated projects visible
3. Click "7 days" - only recent releases visible
4. Combine all three filters - results match all criteria
5. Result count shows correct numbers (e.g., "Showing 3 of 610 releases")
6. Click "Clear Filters" - all 610 releases visible again
7. Filter performance <10ms (check DevTools Performance tab)
8. No page reload or network requests during filtering
9. Filters work with infinite scroll items (not just initial batch)

**Requirements coverage:**
- ✅ FILT-01: Filter by project name
- ✅ FILT-02: Filter by status (graduated/incubating)
- ✅ FILT-03: Filter by date range (7/30/90 days)
- ✅ FILT-04: Clear filters button
- ✅ FILT-05: Client-side filtering (<10ms)

**Performance targets:**
- Filter application: <10ms
- No network requests
- Smooth UI updates (no jank)
- Works with all 610+ releases
</verification>

<success_criteria>
1. User can filter releases by project name from dropdown
2. User can filter releases by status (graduated/incubating) from dropdown
3. User can filter releases by date range (All/7/30/90 days) from buttons
4. Filters apply instantly (<10ms) without page reload
5. Result count updates dynamically showing "X of Y releases"
6. Clear button resets all filters and shows all releases
7. Filters work in combination (project + status + date simultaneously)
8. Responsive layout: horizontal on desktop, stacked on mobile
9. Filters work with both SSR and infinite scroll releases
</success_criteria>

<output>
After completion, create `.planning/phases/04-search-and-filtering/04-02-SUMMARY.md` documenting:
- Filtering implementation approach
- Performance measurements
- Component structure and data flow
- Responsive design decisions
- Any deviations from plan
- Evidence of success criteria
</output>
