---
phase: 03-user-interface
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/pages/index.astro
  - src/components/InfiniteScroll.astro
autonomous: true

must_haves:
  truths:
    - "Page loads in <2 seconds on typical broadband connection"
    - "Initial view shows 20-30 releases, more load on scroll"
    - "Scrolling is smooth without layout shift"
    - "User can scroll to bottom and see 'Load More' trigger more releases"
  artifacts:
    - path: "src/components/InfiniteScroll.astro"
      provides: "Client-side infinite scroll logic"
      min_lines: 80
    - path: "src/pages/index.astro"
      provides: "Paginated release loading"
      contains: "InfiniteScroll"
  key_links:
    - from: "src/components/InfiniteScroll.astro"
      to: "window.IntersectionObserver"
      via: "detects scroll position"
      pattern: "IntersectionObserver"
    - from: "src/pages/index.astro"
      to: "JSON.stringify(allReleases)"
      via: "passes data to client"
      pattern: "data-releases"
---

<objective>
Implement client-side infinite scroll to load releases progressively, ensuring the page loads quickly (<2 seconds) and handles 600+ releases smoothly without overwhelming the initial render.

Purpose: Loading 610 releases at once causes slow initial page load and poor perceived performance. Infinite scroll provides instant first paint with 20-30 releases, then loads more as user scrolls, balancing performance and content discovery.

Output: Working infinite scroll that loads releases in batches of 30, with smooth scrolling and no layout shift.
</objective>

<execution_context>
@~/.config/opencode/get-shit-done/workflows/execute-plan.md
@~/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-user-interface/03-01-PLAN.md
@src/pages/index.astro
@src/components/ReleaseCard.astro
</context>

<tasks>

<task type="auto">
  <name>Create InfiniteScroll component with Intersection Observer</name>
  <files>src/components/InfiniteScroll.astro</files>
  <action>
Create `src/components/InfiniteScroll.astro` with client-side loading logic:

```astro
---
// This component wraps release list and provides infinite scroll
// Data is passed via data attribute and hydrated client-side
---

<div class="infinite-scroll-container">
  <div id="release-list" class="releases">
    <!-- Initial releases rendered server-side in index.astro -->
    <slot />
  </div>
  
  <!-- Loading indicator -->
  <div id="loading-indicator" class="loading-indicator" style="display: none;">
    <div class="spinner"></div>
    <p>Loading more releases...</p>
  </div>
  
  <!-- Scroll trigger (invisible element) -->
  <div id="scroll-trigger" class="scroll-trigger"></div>
  
  <!-- End of content -->
  <div id="end-message" class="end-message" style="display: none;">
    <p>ðŸŽ‰ You've reached the end! All {allReleasesCount} releases loaded.</p>
  </div>
</div>

<script>
  // Infinite scroll implementation using Intersection Observer
  (function() {
    const BATCH_SIZE = 30;
    let currentIndex = BATCH_SIZE; // Start after initial batch
    let isLoading = false;
    let allReleases: any[] = [];
    
    // Get data from parent element
    const container = document.querySelector('.infinite-scroll-container');
    const releaseList = document.getElementById('release-list');
    const scrollTrigger = document.getElementById('scroll-trigger');
    const loadingIndicator = document.getElementById('loading-indicator');
    const endMessage = document.getElementById('end-message');
    
    if (!container || !releaseList || !scrollTrigger) {
      console.error('Infinite scroll: Required elements not found');
      return;
    }
    
    // Get releases data from data attribute (passed from index.astro)
    const releasesData = container.getAttribute('data-releases');
    if (releasesData) {
      try {
        allReleases = JSON.parse(releasesData);
        console.log(`[InfiniteScroll] Loaded ${allReleases.length} releases`);
      } catch (e) {
        console.error('[InfiniteScroll] Failed to parse releases data:', e);
        return;
      }
    }
    
    // Function to render a single release card
    function renderReleaseCard(release: any): string {
      const data = release.data;
      const formattedDate = data.isoDate
        ? new Date(data.isoDate).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'long',
            day: 'numeric',
          })
        : null;
      
      const projectStatus = data.projectStatus
        ? `<span class="project-status ${data.projectStatus}">${data.projectStatus}</span>`
        : '';
      
      const projectDescription = data.projectDescription
        ? `<p class="project-description">${escapeHtml(data.projectDescription)}</p>`
        : '';
      
      const dateHtml = formattedDate
        ? `<div class="release-date"><time datetime="${data.isoDate}">${formattedDate}</time></div>`
        : '';
      
      // Use contentSnippet for preview (markdown rendering happens server-side for initial batch)
      const contentPreview = data.contentSnippet
        ? `<div class="release-content">${escapeHtml(data.contentSnippet.substring(0, 300))}${data.contentSnippet.length > 300 ? '...' : ''}</div>`
        : '';
      
      return `
        <article class="release-card">
          <div class="release-header">
            <span class="project-name">${escapeHtml(data.projectName || data.feedTitle || 'Unknown Project')}</span>
            ${projectStatus}
          </div>
          ${projectDescription}
          <h2 class="release-title">
            <a href="${escapeHtml(data.link)}" target="_blank" rel="noopener noreferrer">
              ${escapeHtml(data.title)}
            </a>
          </h2>
          ${dateHtml}
          ${contentPreview}
        </article>
      `;
    }
    
    // HTML escape utility
    function escapeHtml(text: string): string {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
    
    // Load next batch of releases
    function loadMoreReleases() {
      if (isLoading || currentIndex >= allReleases.length) {
        return;
      }
      
      isLoading = true;
      if (loadingIndicator) loadingIndicator.style.display = 'block';
      
      // Simulate network delay for smooth UX (even though data is local)
      setTimeout(() => {
        const batch = allReleases.slice(currentIndex, currentIndex + BATCH_SIZE);
        
        batch.forEach(release => {
          const html = renderReleaseCard(release);
          if (releaseList) {
            releaseList.insertAdjacentHTML('beforeend', html);
          }
        });
        
        currentIndex += BATCH_SIZE;
        isLoading = false;
        
        if (loadingIndicator) loadingIndicator.style.display = 'none';
        
        // Check if we've loaded everything
        if (currentIndex >= allReleases.length) {
          if (scrollTrigger) scrollTrigger.style.display = 'none';
          if (endMessage) endMessage.style.display = 'block';
        }
        
        console.log(`[InfiniteScroll] Loaded batch, now showing ${currentIndex}/${allReleases.length}`);
      }, 300);
    }
    
    // Set up Intersection Observer
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !isLoading) {
            loadMoreReleases();
          }
        });
      },
      {
        root: null,
        rootMargin: '200px', // Trigger 200px before reaching trigger element
        threshold: 0,
      }
    );
    
    observer.observe(scrollTrigger);
    
    // Cleanup on page unload
    window.addEventListener('beforeunload', () => {
      observer.disconnect();
    });
  })();
</script>

<style>
  .infinite-scroll-container {
    position: relative;
  }
  
  .releases {
    /* Releases container */
  }
  
  .scroll-trigger {
    height: 1px;
    margin: 2rem 0;
  }
  
  .loading-indicator {
    text-align: center;
    padding: 2rem;
    color: var(--color-text-secondary, #57606a);
  }
  
  .spinner {
    width: 40px;
    height: 40px;
    margin: 0 auto 1rem;
    border: 4px solid rgba(0, 0, 0, 0.1);
    border-left-color: var(--color-accent-emphasis, #0969da);
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
  }
  
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
  
  .end-message {
    text-align: center;
    padding: 2rem;
    color: var(--color-text-secondary, #57606a);
    font-size: 0.875rem;
  }
</style>
```

**Why Intersection Observer:**
- Native browser API (no library needed)
- Highly performant (GPU-accelerated)
- Triggers before user reaches bottom (rootMargin: 200px)
- Automatically handles visibility detection

**Why client-side rendering for batches:**
- Initial 30 releases are server-rendered (SEO, instant paint)
- Remaining releases render client-side as needed
- No need for full markdown rendering in subsequent batches (use contentSnippet for preview)
- Keeps bundle size small
  </action>
  <verify>
```bash
# Check component exists
ls src/components/InfiniteScroll.astro && echo "âœ… InfiniteScroll component created"

# Verify key elements
grep -q "IntersectionObserver" src/components/InfiniteScroll.astro && echo "âœ… Uses IntersectionObserver"
grep -q "BATCH_SIZE" src/components/InfiniteScroll.astro && echo "âœ… Batch loading implemented"
grep -q "data-releases" src/components/InfiniteScroll.astro && echo "âœ… Data hydration ready"
```
  </verify>
  <done>
- InfiniteScroll.astro created with Intersection Observer
- Batch size set to 30 releases
- Loading indicator and end message included
- Client-side rendering logic implemented
- Smooth scroll behavior with 200px preload margin
  </done>
</task>

<task type="auto">
  <name>Integrate InfiniteScroll into index.astro with initial batch</name>
  <files>src/pages/index.astro</files>
  <action>
Update `src/pages/index.astro` to use InfiniteScroll component:

1. Import InfiniteScroll component
2. Render only first 30 releases server-side (for SEO and fast initial paint)
3. Pass remaining releases as JSON data attribute for client-side loading
4. Keep stats and error banner at top

Replace the `<main>` section in index.astro:

```astro
---
import { getCollection } from 'astro:content';
import ReleaseCard from '../components/ReleaseCard.astro';
import InfiniteScroll from '../components/InfiniteScroll.astro';

// ... (keep existing collection fetch and sorting)

// Pagination: Initial batch for server-side render
const INITIAL_BATCH = 30;
const initialReleases = sortedReleases.slice(0, INITIAL_BATCH);
const remainingReleases = sortedReleases.slice(INITIAL_BATCH);

// Serialize remaining releases for client-side hydration
// Note: Only pass minimal data (no full markdown content) to keep JSON small
const remainingReleasesData = remainingReleases.map(r => ({
  id: r.id,
  data: {
    title: r.data.title,
    link: r.data.link,
    isoDate: r.data.isoDate,
    contentSnippet: r.data.contentSnippet,
    projectName: r.data.projectName,
    projectDescription: r.data.projectDescription,
    projectStatus: r.data.projectStatus,
    feedTitle: r.data.feedTitle,
  }
}));
---

<!DOCTYPE html>
<html lang="en">
<head>
  <!-- ... (keep existing head) ... -->
</head>
<body>
  <header class="site-header">
    <!-- ... (keep existing header) ... -->
  </header>
  
  <main class="container">
    <!-- Stats bar (keep existing) -->
    <div class="stats">
      <!-- ... -->
    </div>
    
    <!-- Infinite scroll container with data hydration -->
    <div class="infinite-scroll-container" data-releases={JSON.stringify(remainingReleasesData)} data-all-releases-count={sortedReleases.length}>
      <InfiniteScroll>
        <!-- Initial batch rendered server-side -->
        {initialReleases.map((release) => (
          <ReleaseCard release={release} />
        ))}
      </InfiniteScroll>
    </div>
  </main>
  
  <footer class="site-footer">
    <!-- ... (keep existing footer) ... -->
  </footer>
</body>
</html>

<!-- ... (keep existing styles) ... -->
```

**Key implementation notes:**
- First 30 releases: Server-rendered with full markdown (SEO, instant visibility)
- Remaining 580 releases: JSON data passed via data attribute, rendered client-side on scroll
- Minimal data serialization: Only essential fields in JSON (not full content HTML)
- Total JSON payload: ~100-150KB (acceptable for client-side hydration)

**Performance benefits:**
- Initial HTML: ~200KB (30 releases with markdown)
- Time to First Contentful Paint: <1 second
- Time to Interactive: <2 seconds
- Remaining content: Loaded progressively, zero impact on initial load
  </action>
  <verify>
```bash
# Build and check output size
npm run build

# Check bundle size
ls -lh dist/index.html | awk '{print "HTML size: " $5}'

# Verify InfiniteScroll usage
grep -q "InfiniteScroll" src/pages/index.astro && echo "âœ… InfiniteScroll component used"
grep -q "data-releases" src/pages/index.astro && echo "âœ… Data hydration configured"
grep -q "INITIAL_BATCH" src/pages/index.astro && echo "âœ… Batch size defined"

# Check that initial batch is small
grep -c "ReleaseCard" dist/index.html | awk '{if($1<=35) print "âœ… Initial batch size OK ("$1" cards)"; else print "âŒ Too many initial releases ("$1")"}'
```
  </verify>
  <done>
- index.astro imports and uses InfiniteScroll component
- First 30 releases rendered server-side
- Remaining releases passed as JSON data attribute
- Build succeeds with reasonable HTML size (<500KB)
- Page structure preserved (header, stats, releases, footer)
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Infinite scroll implementation with 30 initial releases, progressive loading of remaining 580+ releases, smooth scroll behavior with loading indicator
  </what-built>
  <how-to-verify>
1. Build and preview the site:
```bash
npm run build
npm run preview
```

2. Open browser to http://localhost:4321

3. Performance check:
   - Open DevTools Network tab
   - Hard refresh (Cmd/Ctrl + Shift + R)
   - Check "Time to First Contentful Paint" < 1 second
   - Check "Time to Interactive" < 2 seconds
   - Check initial HTML size < 500KB

4. Scroll behavior:
   - Scroll down slowly through first 20-30 releases
   - Watch for "Loading more releases..." indicator to appear
   - Verify smooth scroll (no jank or layout shift)
   - Continue scrolling to load 2-3 more batches
   - Verify new releases appear seamlessly

5. End state:
   - Scroll to bottom (or close to it)
   - Verify "You've reached the end!" message appears
   - Verify loading indicator stops

6. Content verification:
   - First 30 releases have full markdown rendering
   - Subsequent releases have text previews (not full markdown - that's expected)
   - All releases show project name, status badge, date, description

**Expected behavior:**
- âœ… Page loads instantly (<2s)
- âœ… First 30 releases visible immediately
- âœ… Smooth scrolling with no layout shift
- âœ… Loading indicator appears ~200px before end of current content
- âœ… New batches load automatically
- âœ… End message appears after all releases loaded
  </how-to-verify>
  <resume-signal>
Type "approved" if infinite scroll works smoothly, or describe any issues (janky scrolling, slow loading, layout shifts, errors in console)
  </resume-signal>
</task>

</tasks>

<verification>
**Automated checks:**
```bash
# Build verification
npm run build

# Bundle size check
ls -lh dist/index.html

# Performance check (Lighthouse CLI if available)
npx lighthouse http://localhost:4321 --only-categories=performance --quiet
```

**Manual verification (see checkpoint task):**
- Initial page load < 2 seconds
- Smooth infinite scroll
- Loading indicator appears
- All releases eventually loadable

**Requirement coverage:**
- PERF-02: Page loads in <2 seconds âœ…
- DISP-01: Chronological display (maintained from Plan 01) âœ…
</verification>

<success_criteria>
1. âœ… Page loads in <2 seconds on typical broadband
2. âœ… Initial HTML < 500KB (30 releases server-rendered)
3. âœ… Scroll is smooth without layout shift
4. âœ… Loading indicator appears during batch loading
5. âœ… New batches load automatically when scrolling near bottom
6. âœ… End message appears when all releases loaded
7. âœ… No JavaScript errors in browser console
</success_criteria>

<output>
After completion, create `.planning/phases/03-user-interface/03-02-SUMMARY.md` with:
- Initial batch size (30)
- Total JSON payload size for remaining releases
- Intersection Observer configuration (rootMargin, threshold)
- Measured page load time and Time to Interactive
- Any performance optimizations applied
- Browser compatibility notes
</output>
