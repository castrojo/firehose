# Architecture

**Analysis Date:** 2026-01-26

## Pattern Overview

**Overall:** Build-time Static Site Generation with Client-Side Enhancement

**Key Characteristics:**
- Feed aggregation and HTML processing happens at build-time, not runtime
- Static HTML output with zero server-side processing
- Client-side JavaScript progressively enhances the page with cached data
- Hybrid approach: osmosfeed handles feed aggregation, custom scripts enrich content

## Layers

**Configuration Layer:**
- Purpose: Define feed sources and build settings
- Location: `osmosfeed.yaml`, `package.json`
- Contains: RSS/Atom feed URLs, build scripts, metadata
- Depends on: Nothing (entry point)
- Used by: Build pipeline

**Build Pipeline Layer:**
- Purpose: Orchestrate feed fetching, data extraction, and static site generation
- Location: `package.json` scripts, `.github/workflows/update-feed.yaml`
- Contains: Build command chain, CI/CD workflow
- Depends on: Configuration layer, osmosfeed dependency
- Used by: GitHub Actions, local development

**Data Extraction Layer:**
- Purpose: Fetch external data and enrich feed content
- Location: `scripts/`
- Contains: Landscape fetcher, HTML extractor, data cache generator
- Depends on: osmosfeed output (`public/cache.json`)
- Used by: Build pipeline

**Template Layer:**
- Purpose: Transform feed data into HTML structure
- Location: `includes/index.hbs`
- Contains: Handlebars template with semantic HTML
- Depends on: osmosfeed data model
- Used by: osmosfeed build process

**Static Assets Layer:**
- Purpose: Styling and client-side behavior
- Location: `static/`
- Contains: CSS, JavaScript modules for enhancement
- Depends on: Template layer (DOM structure), data files in `public/`
- Used by: Browser at runtime

**Output Layer:**
- Purpose: Deployable static site
- Location: `public/`
- Contains: Generated HTML, CSS, JS, JSON data caches
- Depends on: All previous layers
- Used by: Web server (GitHub Pages)

## Data Flow

**Build-Time Flow:**

1. **Feed Aggregation**: `osmosfeed` reads `osmosfeed.yaml` ‚Üí fetches all RSS/Atom feeds ‚Üí generates `public/cache.json` and initial `public/index.html`
2. **Landscape Enrichment**: `scripts/fetch-landscape-data.js` ‚Üí fetches CNCF landscape YAML ‚Üí parses project metadata ‚Üí writes `public/landscape-data.json`
3. **HTML Extraction**: `scripts/extract-html.js` ‚Üí reads `public/cache.json` ‚Üí fetches Atom feeds again ‚Üí extracts `<content>` HTML ‚Üí matches projects to landscape data ‚Üí enriches `cache.json` with `htmlContent`, `projectName`, `projectDescription`
4. **Cache Generation**: `scripts/create-html-data.js` ‚Üí reads enriched `cache.json` ‚Üí creates `public/html-content.json` lookup map (link ‚Üí HTML)
5. **Static Copy**: Build copies `static/*` to `public/`

**Runtime Flow:**

1. Browser loads `public/index.html` (generated by osmosfeed)
2. `html-loader.js` loads ‚Üí fetches `html-content.json` ‚Üí injects HTML into `.release-body` divs
3. `project-info-loader.js` loads ‚Üí fetches `landscape-data.json` ‚Üí updates project names and descriptions in `.source-header` elements
4. `index.js` handles accordion state management and timestamp rendering

**State Management:**
- No runtime state beyond localStorage for UI preferences (accordion open/closed)
- All content state is pre-computed at build time
- Data flows unidirectionally: configuration ‚Üí build ‚Üí static files ‚Üí browser

## Key Abstractions

**Feed Source:**
- Purpose: Represents a single RSS/Atom feed
- Examples: GitHub releases feed, project blog RSS
- Pattern: Configured in `osmosfeed.yaml`, transformed into source objects in `cache.json`

**Article:**
- Purpose: Individual feed item (release, blog post)
- Examples: Kubernetes v1.28 release, Istio blog post
- Pattern: Contains `link`, `title`, `description`, optionally `htmlContent`

**Project:**
- Purpose: CNCF project metadata
- Examples: Dapr, Kubernetes, Istio
- Pattern: Keyed by `org/repo` or project name in `landscape-data.json`

**HTML Content Cache:**
- Purpose: Pre-extracted HTML from Atom feeds
- Examples: Full release notes HTML
- Pattern: Lookup map `{articleLink: htmlContent}` in `html-content.json`

## Entry Points

**Build Entry Point:**
- Location: `package.json` scripts.build
- Triggers: `npm run build`, GitHub Actions workflow
- Responsibilities: Execute full build pipeline (osmosfeed ‚Üí fetch landscape ‚Üí extract HTML ‚Üí create cache)

**CI/CD Entry Point:**
- Location: `.github/workflows/update-feed.yaml`
- Triggers: Push to main, daily cron schedule, manual dispatch
- Responsibilities: Run build, deploy to GitHub Pages

**Template Entry Point:**
- Location: `includes/index.hbs`
- Triggers: osmosfeed build process
- Responsibilities: Render HTML structure from osmosfeed data model

**Client Entry Points:**
- Location: `static/html-loader.js`, `static/project-info-loader.js`, `static/index.js`
- Triggers: DOMContentLoaded event
- Responsibilities: Progressive enhancement (inject HTML, update project info, manage UI state)

## Error Handling

**Strategy:** Graceful degradation with fallbacks

**Patterns:**
- Build scripts catch fetch errors and create empty caches rather than failing
- Client-side loaders use try-catch and console warnings, never block page render
- Missing `htmlContent` falls back to `description` text in template
- Missing landscape data displays feed title instead of project name

## Cross-Cutting Concerns

**Logging:** Console output with emoji prefixes (üåç, ‚úÖ, ‚ùå) in build scripts; `console.log/error/warn` in client scripts

**Validation:** Minimal; relies on osmosfeed's validation of YAML config and feed formats

**Authentication:** Not applicable; all sources are public RSS/Atom feeds

**Caching:** 
- Build-time: JSON files in `public/` serve as permanent caches
- Runtime: localStorage for feed cache (30min TTL) in `release-html-renderer.js` (unused in current flow)

---

*Architecture analysis: 2026-01-26*
